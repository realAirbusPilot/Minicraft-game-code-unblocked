// Mini-craft with natural bending crouch animation and smooth terrain
// Paste into browser console to run
(() => {
  if (window.miniCraftFixed) {
    try { window.miniCraftFixed.destroy(); } catch(e) {}
  }

  // ---------- Config ----------
  const TILE = 24;
  const WORLD_W = 900;
  const WORLD_H = 160;
  const PHYSICS_HZ = 60;
  const DT = 1 / PHYSICS_HZ;
  const MAX_SUBSTEP = TILE * 0.45;
  const GRAVITY = 1400, JUMP_V = -320, WALK_SPEED = 160, FRICTION = 12;
  const REACH_TILES = 6.5;
  const MAX_STACK = 64;

  // Game state
  let gameState = "title";
  let keybinds = {
    left: "a",
    right: "d",
    jump: "w",
    mine: "leftclick",
    place: "rightclick"
  };
  let rebindingKey = null;

  // Day/night cycle configuration (10 minutes each)
  const DAY_MS = 10 * 60 * 1000;
  const NIGHT_MS = 10 * 60 * 1000;
  const CYCLE_MS = DAY_MS + NIGHT_MS;
  const worldStartTime = Date.now() - Math.floor(Math.random() * CYCLE_MS);

  let currentZoom = 1.0, targetZoom = 1.0;
  const ZOOM_MIN = 0.5, ZOOM_MAX = 3.0;
  const devicePixelRatio_ = Math.max(1, window.devicePixelRatio || 1);

  // ---------- Blocks ----------
  const BLOCKS = {
    0: { name:"Air", color:null, solid:false, hp:0, drop:0 },
    1: { name:"Grass", color:"#5a7b3e", solid:true, hp:40, drop:1 },
    2: { name:"Dirt",  color:"#7b5136", solid:true, hp:35, drop:2 },
    3: { name:"Stone", color:"#6d6d6d", solid:true, hp:95, drop:3 },
    4: { name:"Oak Wood", color:"#8d5a33", solid:true, hp:60, drop:4 },
    5: { name:"Oak Leaves", color:"#3f7a3a", solid:false, hp:20, drop:5 },
    11:{ name:"Rock", color:"#8a8f94", solid:true, hp:110, drop:11 }
  };

  // ---------- DOM & canvases ----------
  const root = document.createElement("div");
  Object.assign(root.style, {
    position:"fixed", left:0, top:0, width:"100%", height:"100%", 
    zIndex:2147483647, pointerEvents:"none"
  });
  document.body.appendChild(root);

  const bgCanvas = document.createElement("canvas");
  Object.assign(bgCanvas.style, { 
    position:"absolute", left:0, top:0, width:"100%", height:"100%", 
    pointerEvents:"none", zIndex:1 
  });
  root.appendChild(bgCanvas);
  const bgCtx = bgCanvas.getContext("2d", { alpha:false });

  const worldCanvas = document.createElement("canvas");
  Object.assign(worldCanvas.style, { 
    position:"absolute", left:0, top:0, width:"100%", height:"100%", 
    pointerEvents:"auto", cursor:"crosshair", zIndex:2, imageRendering:"pixelated" 
  });
  root.appendChild(worldCanvas);
  const wctx = worldCanvas.getContext("2d", { alpha:true });

  const overlay = document.createElement("canvas");
  Object.assign(overlay.style, { 
    position:"absolute", left:0, top:0, width:"100%", height:"100%", 
    pointerEvents:"none", zIndex:3, imageRendering:"pixelated" 
  });
  root.appendChild(overlay);
  const octx = overlay.getContext("2d", { alpha:true });

  const help = document.createElement("div");
  help.innerText = "A/D: move • W/Space: jump • Shift: crouch • Left: mine • Right: place • 1-9: select • Esc: menu";
  Object.assign(help.style, { 
    position:"absolute", left:"12px", top:"12px", background:"rgba(0,0,0,0.55)", 
    color:"#fff", padding:"8px 10px", borderRadius:"8px", fontFamily:"monospace", 
    pointerEvents:"none", zIndex:4, display:"none"
  });
  root.appendChild(help);

  const sliderWrap = document.createElement("div");
  Object.assign(sliderWrap.style, { 
    position:"absolute", left:"120px", bottom:"106px", pointerEvents:"auto", 
    zIndex:4, display:"none", alignItems:"center", gap:"8px", fontFamily:"monospace" 
  });
  const sliderLabel = document.createElement("div");
  sliderLabel.textContent = "Zoom";
  sliderLabel.style.color = "#fff";
  const zoomSlider = document.createElement("input");
  zoomSlider.type = "range";
  zoomSlider.min = String(ZOOM_MIN);
  zoomSlider.max = String(ZOOM_MAX);
  zoomSlider.step = "0.01";
  zoomSlider.value = String(currentZoom);
  Object.assign(zoomSlider.style, { width:"220px", height:"10px" });
  const sliderValue = document.createElement("div");
  sliderValue.textContent = `${currentZoom.toFixed(2)}x`;
  sliderValue.style.color = "#fff";
  sliderWrap.appendChild(sliderLabel);
  sliderWrap.appendChild(zoomSlider);
  sliderWrap.appendChild(sliderValue);
  root.appendChild(sliderWrap);
  zoomSlider.addEventListener("input", (e) => {
    targetZoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, parseFloat(e.target.value)));
    sliderValue.textContent = `${targetZoom.toFixed(2)}x`;
  });

  // ---------- Title Screen UI ----------
  const titleScreen = document.createElement("div");
  Object.assign(titleScreen.style, {
    position: "absolute", left: "0", top: "0", width: "100%", height: "100%",
    display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center",
    zIndex: "5", pointerEvents: "auto", fontFamily: "monospace"
  });

  const titleText = document.createElement("div");
  titleText.textContent = "MINI-CRAFT";
  Object.assign(titleText.style, {
    fontSize: "64px", fontWeight: "bold", color: "#fff",
    textShadow: "4px 4px 8px rgba(0,0,0,0.8)", marginBottom: "60px", letterSpacing: "4px"
  });
  titleScreen.appendChild(titleText);

  const playButton = document.createElement("button");
  playButton.textContent = "PLAY GAME";
  Object.assign(playButton.style, {
    fontSize: "24px", padding: "16px 48px", background: "rgba(74, 144, 226, 0.9)",
    color: "#fff", border: "3px solid #fff", borderRadius: "8px", cursor: "pointer",
    fontFamily: "monospace", fontWeight: "bold", marginBottom: "20px", transition: "all 0.2s"
  });
  
  playButton.addEventListener("mouseenter", () => {
    playButton.style.background = "rgba(74, 144, 226, 1)";
    playButton.style.transform = "scale(1.1)";
  });
  
  playButton.addEventListener("mouseleave", () => {
    playButton.style.background = "rgba(74, 144, 226, 0.9)";
    playButton.style.transform = "scale(1)";
  });
  
  playButton.addEventListener("click", () => {
    gameState = "playing";
    titleScreen.style.display = "none";
    help.style.display = "block";
    sliderWrap.style.display = "flex";
  });
  
  titleScreen.appendChild(playButton);

  const settingsButton = document.createElement("button");
  settingsButton.textContent = "SETTINGS";
  Object.assign(settingsButton.style, {
    fontSize: "20px", padding: "12px 36px", background: "rgba(109, 109, 109, 0.9)",
    color: "#fff", border: "2px solid #fff", borderRadius: "8px", cursor: "pointer",
    fontFamily: "monospace", fontWeight: "bold", transition: "all 0.2s"
  });
  
  settingsButton.addEventListener("mouseenter", () => {
    settingsButton.style.background = "rgba(109, 109, 109, 1)";
    settingsButton.style.transform = "scale(1.05)";
  });
  
  settingsButton.addEventListener("mouseleave", () => {
    settingsButton.style.background = "rgba(109, 109, 109, 0.9)";
    settingsButton.style.transform = "scale(1)";
  });
  
  settingsButton.addEventListener("click", () => {
    gameState = "settings";
    titleScreen.style.display = "none";
    settingsScreen.style.display = "flex";
  });
  
  titleScreen.appendChild(settingsButton);
  root.appendChild(titleScreen);

  // ---------- Settings Screen UI ----------
  const settingsScreen = document.createElement("div");
  Object.assign(settingsScreen.style, {
    position: "absolute", left: "0", top: "0", width: "100%", height: "100%",
    display: "none", flexDirection: "column", alignItems: "center", justifyContent: "center",
    zIndex: "5", pointerEvents: "auto", fontFamily: "monospace"
  });

  const settingsTitle = document.createElement("div");
  settingsTitle.textContent = "SETTINGS - KEYBINDS";
  Object.assign(settingsTitle.style, {
    fontSize: "48px", fontWeight: "bold", color: "#fff",
    textShadow: "4px 4px 8px rgba(0,0,0,0.8)", marginBottom: "40px"
  });
  settingsScreen.appendChild(settingsTitle);

  const keybindsContainer = document.createElement("div");
  Object.assign(keybindsContainer.style, {
    background: "rgba(0,0,0,0.7)", padding: "30px", borderRadius: "12px", marginBottom: "30px"
  });

  const keybindsList = [
    { key: "left", label: "Move Left" },
    { key: "right", label: "Move Right" },
    { key: "jump", label: "Jump" }
  ];

  keybindsList.forEach(({ key, label }) => {
    const row = document.createElement("div");
    Object.assign(row.style, {
      display: "flex", justifyContent: "space-between", alignItems: "center",
      marginBottom: "15px", gap: "40px"
    });

    const labelDiv = document.createElement("div");
    labelDiv.textContent = label + ":";
    Object.assign(labelDiv.style, { fontSize: "20px", color: "#fff", minWidth: "150px" });

    const keyButton = document.createElement("button");
    keyButton.textContent = keybinds[key].toUpperCase();
    keyButton.dataset.bindKey = key;
    Object.assign(keyButton.style, {
      fontSize: "18px", padding: "10px 30px", background: "rgba(74, 144, 226, 0.9)",
      color: "#fff", border: "2px solid #fff", borderRadius: "6px", cursor: "pointer",
      fontFamily: "monospace", minWidth: "120px", transition: "all 0.2s"
    });

    keyButton.addEventListener("click", () => {
      rebindingKey = key;
      keyButton.textContent = "PRESS KEY...";
      keyButton.style.background = "rgba(255, 200, 80, 0.9)";
    });

    row.appendChild(labelDiv);
    row.appendChild(keyButton);
    keybindsContainer.appendChild(row);
  });

  settingsScreen.appendChild(keybindsContainer);

  const backButton = document.createElement("button");
  backButton.textContent = "BACK TO MENU";
  Object.assign(backButton.style, {
    fontSize: "20px", padding: "12px 36px", background: "rgba(109, 109, 109, 0.9)",
    color: "#fff", border: "2px solid #fff", borderRadius: "8px", cursor: "pointer",
    fontFamily: "monospace", fontWeight: "bold", transition: "all 0.2s"
  });

  backButton.addEventListener("mouseenter", () => {
    backButton.style.background = "rgba(109, 109, 109, 1)";
    backButton.style.transform = "scale(1.05)";
  });

  backButton.addEventListener("mouseleave", () => {
    backButton.style.background = "rgba(109, 109, 109, 0.9)";
    backButton.style.transform = "scale(1)";
  });

  backButton.addEventListener("click", () => {
    gameState = "title";
    settingsScreen.style.display = "none";
    titleScreen.style.display = "flex";
    rebindingKey = null;
  });

  settingsScreen.appendChild(backButton);
  root.appendChild(settingsScreen);

  // ---------- Noise helpers ----------
  function iHash(n) {
    n = (n|0);
    n = (n + 0x7ed55d16) + (n << 12);
    n = (n ^ 0xc761c23c) ^ (n >>> 19);
    n = (n + 0x165667b1) + (n << 5);
    n = (n + 0xd3a2646c) ^ (n << 9);
    return n >>> 0;
  }

  // ---------- Map generation ----------
  const map = new Uint8Array(WORLD_W * WORLD_H);
  const idx = (x,y) => y*WORLD_W + x;

  function generateTerrain() {
    const baseHeight = Math.floor(WORLD_H * 0.52);
    const heights = new Array(WORLD_W).fill(baseHeight);
    const numHills = 1 + Math.floor(Math.random() * 2);
    
    for (let h = 0; h < numHills; h++) {
      const hillCenter = Math.floor(WORLD_W * 0.2) + Math.floor(Math.random() * WORLD_W * 0.6);
      const hillPeakHeight = 2 + Math.floor(Math.random() * 3);
      const hillBaseWidth = 30 + Math.floor(Math.random() * 40);
      
      for (let x = 0; x < WORLD_W; x++) {
        const distFromCenter = Math.abs(x - hillCenter);
        if (distFromCenter < hillBaseWidth) {
          const normalizedDist = distFromCenter / hillBaseWidth;
          const heightFactor = Math.pow(1 - normalizedDist, 2);
          const hillHeight = Math.floor(hillPeakHeight * heightFactor);
          heights[x] += hillHeight;
        }
      }
    }
    
    for (let pass = 0; pass < 5; pass++) {
      for (let x = 1; x < WORLD_W; x++) {
        const diff = heights[x] - heights[x - 1];
        if (diff > 1) heights[x] = heights[x - 1] + 1;
        else if (diff < -1) heights[x] = heights[x - 1] - 1;
      }
      for (let x = WORLD_W - 2; x >= 0; x--) {
        const diff = heights[x] - heights[x + 1];
        if (diff > 1) heights[x] = heights[x + 1] + 1;
        else if (diff < -1) heights[x] = heights[x + 1] - 1;
      }
    }
    
    for (let x = 0; x < WORLD_W; x++) {
      const surfaceY = heights[x];
      for (let y = 0; y < WORLD_H; y++) {
        if (y < surfaceY) map[idx(x, y)] = 0;
        else if (y === surfaceY) map[idx(x, y)] = 1;
        else if (y < surfaceY + 4) map[idx(x, y)] = 2;
        else map[idx(x, y)] = 3;
      }
    }
    
    for (let pass = 0; pass < 3; pass++) {
      for (let x = 1; x < WORLD_W - 1; x++) {
        for (let y = 1; y < WORLD_H - 1; y++) {
          const current = map[idx(x, y)];
          const below = map[idx(x, y + 1)];
          const left = map[idx(x - 1, y)];
          const right = map[idx(x + 1, y)];
          if (current === 0 && left !== 0 && right !== 0 && below !== 0) {
            map[idx(x, y)] = 2;
          }
        }
      }
    }
    
    // Generate trees
    const numTrees = 40 + Math.floor(Math.random() * 30);
    const treePositions = [];
    
    for (let t = 0; t < numTrees; t++) {
      const tx = 10 + Math.floor(Math.random() * (WORLD_W - 20));
      
      // Check if too close to existing trees (minimum 8 blocks apart)
      let tooClose = false;
      for (const pos of treePositions) {
        if (Math.abs(pos - tx) < 8) {
          tooClose = true;
          break;
        }
      }
      if (tooClose) continue;
      
      let surfaceY = 0;
      for (let y = 0; y < WORLD_H; y++) {
        if (map[idx(tx, y)] !== 0) { surfaceY = y; break; }
      }
      
      // Check if there's enough space (no blocks above for 6 tiles)
      let canPlaceTree = true;
      for (let cy = surfaceY - 6; cy < surfaceY; cy++) {
        if (cy < 0 || map[idx(tx, cy)] !== 0) { canPlaceTree = false; break; }
      }
      
      // Also check the blocks immediately around the trunk position
      for (let dx = -2; dx <= 2; dx++) {
        const checkX = tx + dx;
        if (checkX >= 0 && checkX < WORLD_W) {
          for (let dy = surfaceY - 6; dy < surfaceY; dy++) {
            if (dy >= 0 && map[idx(checkX, dy)] !== 0) {
              canPlaceTree = false;
              break;
            }
          }
        }
        if (!canPlaceTree) break;
      }
      
      if (!canPlaceTree) continue;
      
      // Add to tree positions
      treePositions.push(tx);
      
      // Tree trunk (4-5 blocks tall)
      const trunkHeight = 4 + Math.floor(Math.random() * 2);
      for (let ty = 0; ty < trunkHeight; ty++) {
        const y = surfaceY - 1 - ty;
        if (y >= 0) map[idx(tx, y)] = 4;
      }
      
      // Tree leaves (crown shape)
      const crownY = surfaceY - trunkHeight;
      const crownRadius = 2;
      
      for (let dy = -crownRadius; dy <= crownRadius; dy++) {
        for (let dx = -crownRadius; dx <= crownRadius; dx++) {
          const dist = Math.abs(dx) + Math.abs(dy);
          if (dist <= crownRadius && dist > 0) {
            const lx = tx + dx, ly = crownY + dy;
            if (lx >= 0 && lx < WORLD_W && ly >= 0 && ly < WORLD_H) {
              if (map[idx(lx, ly)] === 0) map[idx(lx, ly)] = 5;
            }
          }
        }
      }
      
      // Top leaf
      if (crownY - 1 >= 0) map[idx(tx, crownY - 1)] = 5;
    }
  }

  // ---------- Textures ----------
  const texCache = new Map();

  function makeCanvas(w,h) {
    const c = document.createElement("canvas");
    c.width = w;
    c.height = h;
    return c;
  }

  function genTexture(id) {
    const size = Math.max(16, TILE);
    const c = makeCanvas(size, size);
    const g = c.getContext("2d");
    const def = BLOCKS[id] || { color:"#ffffff" };
    const base = def.color || "#ffffff";
    
    let ci = 0xffffff;
    try { ci = parseInt(base.slice(1), 16); } catch(e) {}
    
    let r = (ci>>16)&0xff, gg = (ci>>8)&0xff, b = ci&0xff;
    const jitter = (iHash(id*7919+37)%21)-10;
    r = Math.max(0, Math.min(255, r+jitter));
    gg = Math.max(0, Math.min(255, gg+jitter));
    b = Math.max(0, Math.min(255, b+jitter));
    
    g.fillStyle = `rgb(${r},${gg},${b})`;
    g.fillRect(0, 0, size, size);

    const speck = 18, alpha = 0.06;
    for (let i=0; i<speck; i++) {
      const rx = Math.floor(iHash(id*97 + i*131) % size);
      const ry = Math.floor(iHash(id*193 + i*71) % size);
      const rw = 1 + (iHash(id*19 + i*29) % 2);
      const rh = 1 + (iHash(id*23 + i*31) % 2);
      const a = alpha + ((iHash(id*47 + i*53) % 20)/1000);
      g.fillStyle = `rgba(0,0,0,${a})`;
      g.fillRect(rx, ry, rw, rh);
    }

    if (id === 4) {
      g.fillStyle = "rgba(0,0,0,0.06)";
      for (let y=2; y<size-2; y+=4) {
        g.fillRect(2, y + ((iHash(y+id)%2)), size-4, 1);
      }
    }
    
    if (id === 5) {
      for (let sx=0; sx<size; sx+=4) {
        for (let sy=0; sy<size; sy+=4) {
          if (iHash(sx*97+sy*31+id)%100 < 62) {
            g.fillStyle = "rgba(0,0,0,0.06)";
            g.fillRect(sx+(iHash(sx+sy+id)%2), sy+(iHash(sx*3+sy*7+id)%2), 2, 2);
          }
        }
      }
    }
    
    g.strokeStyle = "rgba(0,0,0,0.03)";
    g.lineWidth = 1;
    g.strokeRect(0.5, 0.5, size-1, size-1);
    return c;
  }

  function buildAllTextures() {
    texCache.clear();
    for (const k of Object.keys(BLOCKS)) {
      const id = Number(k);
      if (id === 0) continue;
      try { texCache.set(id, genTexture(id)); } catch(e) { console.error("tex fail", id, e); }
    }
  }

  // ---------- Stars generation ----------
  let stars = [];

  function generateStars(num=400) {
    stars = [];
    let seed = 1234567;
    const cssW = Math.max(800, window.innerWidth);
    const cssH = Math.max(600, window.innerHeight);
    const palette = ["#ffffff", "#fff5d6", "#ffd6ff", "#d8f6ff"];
    
    for (let i=0; i<num; i++) {
      seed = (seed * 1664525 + 1013904223) >>> 0;
      const x = seed % cssW;
      seed = (seed * 1664525 + 1013904223) >>> 0;
      const y = seed % cssH;
      seed = (seed * 1664525 + 1013904223) >>> 0;
      const size = 0.6 + (seed % 300) / 300;
      seed = (seed * 1664525 + 1013904223) >>> 0;
      const tw = (seed % 100) / 100;
      seed = (seed * 1664525 + 1013904223) >>> 0;
      const col = palette[seed % palette.length];
      seed = (seed * 1664525 + 1013904223) >>> 0;
      const depth = 0.1 + (seed % 100) / 100;
      seed = (seed * 1664525 + 1013904223) >>> 0;
      const brightness = 0.7 + ((seed >> 4) % 200) / 200;
      
      stars.push({ x, y, size, twinkle: tw, color: col, depth, brightness });
    }
  }

  // ---------- Inventory ----------
  const inventory = {};
  for (const id in BLOCKS) inventory[id] = [];
  inventory[1].push(12);

  function addToInventory(bid, amt=1) {
    if (!inventory[bid]) inventory[bid] = [];
    let rem = amt;
    const stacks = inventory[bid];
    for (let i=0; i<stacks.length && rem>0; i++) {
      const space = MAX_STACK - stacks[i];
      const put = Math.min(space, rem);
      stacks[i] += put;
      rem -= put;
    }
    while (rem > 0) {
      stacks.push(Math.min(MAX_STACK, rem));
      rem -= MAX_STACK;
    }
  }

  function removeFromInventory(bid, amt=1) {
    if (!inventory[bid]) return 0;
    let rem = amt;
    const stacks = inventory[bid];
    for (let i=0; i<stacks.length && rem>0; i++) {
      const take = Math.min(stacks[i], rem);
      stacks[i] -= take;
      rem -= take;
    }
    inventory[bid] = stacks.filter(s => s>0);
    return (amt - rem);
  }

  function totalCount(bid) {
    const s = inventory[bid] || [];
    return s.reduce((a,b) => a+b, 0);
  }

  // ---------- Player ----------
  const player = {
    x: 0, y: 0, w: TILE*0.9, h: TILE*2.0, vx: 0, vy: 0,
    onGround: false, selected: 1, facingRight: true,
    walkFrame: 0, walkTimer: 0, jumpTimer: 0,
    crouching: false, crouchProgress: 0,
    normalHeight: TILE*2.0, crouchHeight: TILE*1.5
  };

  // ---------- Player sprite with arms OUTSIDE body ----------
  function drawPlayerSprite(ctx, px, py, pw, ph) {
    const skinColor = "#ffd4a3", skinShadow = "#e0b88a";
    const shirtColor = "#4a90e2", shirtShadow = "#3a7bc8";
    const pantsColor = "#2c5aa0", pantsShadow = "#1e4080";
    const shoeColor = "#2d2d2d";
    
    const crouchAmt = player.crouchProgress;
    const bendAngle = crouchAmt * 0.4;
    const bendForwardX = Math.sin(bendAngle) * ph * 0.3 * (player.facingRight ? 1 : -1);
    const bendDownY = (1 - Math.cos(bendAngle)) * ph * 0.15;
    
    const headSize = ph * 0.35, bodyHeight = ph * 0.38;
    const bodyWidth = pw * 0.5, legHeight = ph * 0.35;
    
    let armSwing = 0, legSwing = 0, bodyBob = 0;
    
    if (player.onGround && Math.abs(player.vx) > 10 && !player.crouching) {
      const walkCycle = (player.walkFrame / 4) * Math.PI * 2;
      armSwing = Math.sin(walkCycle) * pw * 0.12;
      legSwing = Math.sin(walkCycle) * pw * 0.16;
      bodyBob = Math.abs(Math.sin(walkCycle * 2)) * 1.5;
    }
    
    const jumpOffset = player.jumpTimer > 0 ? -2 : 0;
    const isJumping = player.jumpTimer > 0;
    const baseX = px, baseY = py + bodyBob + jumpOffset;
    const torsoBaseY = baseY + ph * 0.42 + bodyHeight;
    
    // === LEGS ===
    const legWidth = pw * 0.22, legY = torsoBaseY;
    
    if (isJumping || player.crouching) {
      const leftLegX = baseX + pw * 0.28, rightLegX = baseX + pw * 0.5;
      const bentFactor = isJumping ? 0.8 : (1 - crouchAmt * 0.2);
      const displayLegHeight = legHeight * bentFactor;
      
      ctx.fillStyle = pantsShadow;
      ctx.fillRect(leftLegX, legY, legWidth, displayLegHeight);
      ctx.fillStyle = pantsColor;
      ctx.fillRect(leftLegX + 1, legY, legWidth - 2, displayLegHeight);
      
      ctx.fillStyle = pantsShadow;
      ctx.fillRect(rightLegX, legY, legWidth, displayLegHeight);
      ctx.fillStyle = pantsColor;
      ctx.fillRect(rightLegX + 1, legY, legWidth - 2, displayLegHeight);
      
      ctx.fillStyle = shoeColor;
      ctx.fillRect(leftLegX, legY + displayLegHeight - 3, legWidth, 3);
      ctx.fillRect(rightLegX, legY + displayLegHeight - 3, legWidth, 3);
    } else {
      const leftLegX = baseX + pw * 0.25, rightLegX = baseX + pw * 0.53;
      
      ctx.fillStyle = pantsShadow;
      ctx.fillRect(leftLegX, legY + legSwing, legWidth, legHeight);
      ctx.fillStyle = pantsColor;
      ctx.fillRect(leftLegX + 1, legY + legSwing, legWidth - 2, legHeight - 1);
      
      ctx.fillStyle = pantsShadow;
      ctx.fillRect(rightLegX, legY - legSwing, legWidth, legHeight);
      ctx.fillStyle = pantsColor;
      ctx.fillRect(rightLegX + 1, legY - legSwing, legWidth - 2, legHeight - 1);
      
      ctx.fillStyle = shoeColor;
      ctx.fillRect(leftLegX, legY + legSwing + legHeight - 3, legWidth, 3);
      ctx.fillRect(rightLegX, legY - legSwing + legHeight - 3, legWidth, 3);
    }
    
    // === BODY ===
    const bodyX = baseX + pw * 0.25 + bendForwardX * 0.6;
    const bodyY = baseY + ph * 0.42 + bendDownY;
    
    ctx.fillStyle = shirtShadow;
    ctx.fillRect(bodyX, bodyY, bodyWidth, bodyHeight);
    ctx.fillStyle = shirtColor;
    ctx.fillRect(bodyX + 1, bodyY, bodyWidth - 2, bodyHeight - 1);
    ctx.fillStyle = "rgba(255,255,255,0.2)";
    ctx.fillRect(bodyX + 2, bodyY + 2, bodyWidth * 0.3, bodyHeight * 0.4);
    ctx.fillStyle = shirtShadow;
    ctx.fillRect(bodyX + bodyWidth * 0.3, bodyY, bodyWidth * 0.4, 3);
    
    // === ARMS - POSITIONED OUTSIDE BODY ===
    const armWidth = pw * 0.16, armHeight = bodyHeight * 0.75;
    const shoulderY = bodyY + bodyHeight * 0.15;
    
    // Back arm - outside body
    const backArmX = player.facingRight ? bodyX - armWidth + 2 : bodyX + bodyWidth - 2;
    const backSwing = isJumping ? -5 : (player.crouching ? 3 : -armSwing);
    
    ctx.fillStyle = shirtShadow;
    ctx.fillRect(backArmX, shoulderY + backSwing, armWidth, armHeight);
    ctx.fillStyle = shirtColor;
    ctx.fillRect(backArmX + 1, shoulderY + backSwing, armWidth - 2, armHeight - 1);
    ctx.fillStyle = skinShadow;
    ctx.fillRect(backArmX, shoulderY + backSwing + armHeight - 4, armWidth, 4);
    ctx.fillStyle = skinColor;
    ctx.fillRect(backArmX + 1, shoulderY + backSwing + armHeight - 4, armWidth - 2, 3);
    
    // Front arm - outside body
    const frontArmX = player.facingRight ? bodyX + bodyWidth - 2 : bodyX - armWidth + 2;
    const frontSwing = isJumping ? -5 : (player.crouching ? 3 : armSwing);
    
    ctx.fillStyle = shirtShadow;
    ctx.fillRect(frontArmX, shoulderY + frontSwing, armWidth, armHeight);
    ctx.fillStyle = shirtColor;
    ctx.fillRect(frontArmX + 1, shoulderY + frontSwing, armWidth - 2, armHeight - 1);
    ctx.fillStyle = skinShadow;
    ctx.fillRect(frontArmX, shoulderY + frontSwing + armHeight - 4, armWidth, 4);
    ctx.fillStyle = skinColor;
    ctx.fillRect(frontArmX + 1, shoulderY + frontSwing + armHeight - 4, armWidth - 2, 3);
    
    // === HEAD ===
    const neckOffsetX = bendForwardX * 0.8, neckOffsetY = bendDownY * 0.5;
    const headX = baseX + pw/2 - headSize/2 + neckOffsetX;
    const headY = baseY + ph * 0.05 + neckOffsetY;
    
    ctx.fillStyle = skinShadow;
    ctx.fillRect(headX, headY, headSize, headSize);
    ctx.fillStyle = skinColor;
    ctx.fillRect(headX + 1, headY + 1, headSize - 2, headSize - 2);
    ctx.fillStyle = "rgba(255,255,255,0.15)";
    ctx.fillRect(headX + 2, headY + 2, headSize * 0.4, headSize * 0.4);
    
    // === FACE ===
    const eyeSize = Math.max(2, headSize * 0.15), eyeY = headY + headSize * 0.4;
    
    if (player.facingRight) {
      const eyeX = headX + headSize * 0.55;
      ctx.fillStyle = "#fff";
      ctx.fillRect(eyeX, eyeY, eyeSize, eyeSize);
      ctx.fillStyle = "#000";
      ctx.fillRect(eyeX + eyeSize * 0.4, eyeY + eyeSize * 0.2, eyeSize * 0.4, eyeSize * 0.6);
    } else {
      const eyeX = headX + headSize * 0.3;
      ctx.fillStyle = "#fff";
      ctx.fillRect(eyeX, eyeY, eyeSize, eyeSize);
      ctx.fillStyle = "#000";
      ctx.fillRect(eyeX + eyeSize * 0.2, eyeY + eyeSize * 0.2, eyeSize * 0.4, eyeSize * 0.6);
    }
    
    // Mouth
    const mouthY = headY + headSize * 0.65, mouthX = headX + headSize * 0.35;
    const mouthWidth = headSize * 0.3;
    ctx.fillStyle = "rgba(0,0,0,0.3)";
    ctx.fillRect(mouthX, mouthY, mouthWidth, isJumping ? 2 : 1);
    
    // Hair
    ctx.fillStyle = "#3d2817";
    ctx.fillRect(headX, headY, headSize, headSize * 0.25);
  }

  // ---------- Input ----------
  const keys = {}, mouse = { x:0, y:0, left:false, right:false, lastRight:false };

  window.addEventListener("keydown", e => {
    const key = e.key.toLowerCase();
    
    if (rebindingKey && gameState === "settings") {
      e.preventDefault();
      keybinds[rebindingKey] = key;
      const buttons = settingsScreen.querySelectorAll("button");
      buttons.forEach(btn => {
        if (btn.dataset.bindKey === rebindingKey) {
          btn.textContent = key.toUpperCase();
          btn.style.background = "rgba(74, 144, 226, 0.9)";
        }
      });
      rebindingKey = null;
      return;
    }
    
    if (gameState === "title" || gameState === "settings") return;
    if (e.key === "Escape") {
      gameState = "title";
      titleScreen.style.display = "flex";
      help.style.display = "none";
      sliderWrap.style.display = "none";
      return;
    }
    keys[key] = true;
    if (e.key >= '1' && e.key <= '9') player.selected = Math.min(11, Number(e.key));
  });

  window.addEventListener("keyup", e => { keys[e.key.toLowerCase()] = false; });

  worldCanvas.addEventListener("mousemove", e => {
    const r = worldCanvas.getBoundingClientRect();
    mouse.x = e.clientX - r.left;
    mouse.y = e.clientY - r.top;
  });

  worldCanvas.addEventListener("mousedown", e => {
    if (gameState !== "playing") return;
    if (e.button === 0) mouse.left = true;
    if (e.button === 2) mouse.right = true;
  });

  window.addEventListener("mouseup", e => {
    if (e.button === 0) mouse.left = false;
    if (e.button === 2) mouse.right = false;
  });

  worldCanvas.addEventListener("contextmenu", e => e.preventDefault());

  // ---------- Spawn player ----------
  function spawnPlayer() {
    const centerX = Math.floor(WORLD_W * 0.5);
    let surfaceY = 0;
    for (let y = 0; y < WORLD_H; y++) {
      if (map[idx(centerX, y)] !== 0) { surfaceY = y; break; }
    }
    player.x = (centerX + 0.5) * TILE;
    player.y = (surfaceY - 3) * TILE;
    player.x = Math.max(2, Math.min(player.x, WORLD_W*TILE - player.w - 2));
  }

  // ---------- Physics ----------
  function aabbOverlap(ax,ay,aw,ah,bx,by,bw,bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function tileAt(tx, ty) {
    if (tx < 0 || ty < 0 || tx >= WORLD_W || ty >= WORLD_H) return 0;
    return map[idx(tx, ty)];
  }

  function tilesOverlapping(px,py,pw,ph) {
    const x1 = Math.floor(px / TILE), y1 = Math.floor(py / TILE);
    const x2 = Math.floor((px + pw - 0.0001) / TILE), y2 = Math.floor((py + ph - 0.0001) / TILE);
    const out = [];
    for (let tx = x1; tx <= x2; tx++) {
      for (let ty = y1; ty <= y2; ty++) {
        if (tx < 0 || tx >= WORLD_W || ty < 0 || ty >= WORLD_H) continue;
        out.push({ tx, ty, id: tileAt(tx, ty) });
      }
    }
    return out;
  }

  function physicsStep(dt) {
    const left = keys[keybinds.left] || keys['arrowleft'];
    const right = keys[keybinds.right] || keys['arrowright'];
    const jump = keys[keybinds.jump] || keys[' '] || keys['arrowup'];
    const crouch = keys['shift'];
    
    const wasCrouching = player.crouching;
    player.crouching = crouch && player.onGround;
    
    const crouchSpeed = 8;
    if (player.crouching) player.crouchProgress = Math.min(1, player.crouchProgress + dt * crouchSpeed);
    else player.crouchProgress = Math.max(0, player.crouchProgress - dt * crouchSpeed);
    
    if (player.crouching && !wasCrouching) {
      const oldBottom = player.y + player.h;
      player.h = player.crouchHeight;
      player.y = oldBottom - player.h;
    } else if (!player.crouching && wasCrouching) {
      const standHeight = player.normalHeight;
      const testY = player.y + player.h - standHeight;
      const canStand = !checkCollision(player.x, testY, player.w, standHeight);
      if (canStand) {
        const oldBottom = player.y + player.h;
        player.h = standHeight;
        player.y = oldBottom - player.h;
      } else player.crouching = true;
    }
    
    let targetVx = 0;
    if (left) { targetVx = -WALK_SPEED; player.facingRight = false; }
    else if (right) { targetVx = WALK_SPEED; player.facingRight = true; }
    
    const alpha = Math.min(1, dt*12);
    player.vx += (targetVx - player.vx) * alpha;
    if (!left && !right) player.vx *= Math.max(0, 1 - FRICTION*dt);
    
    if (player.onGround && Math.abs(player.vx) > 10 && !player.crouching) {
      player.walkTimer += dt;
      if (player.walkTimer > 0.15) {
        player.walkFrame = (player.walkFrame + 1) % 4;
        player.walkTimer = 0;
      }
    } else { player.walkFrame = 0; player.walkTimer = 0; }
    
    if (jump && player.onGround) {
      player.vy = JUMP_V;
      player.onGround = false;
      player.jumpTimer = 0.3;
    }
    
    if (player.jumpTimer > 0) player.jumpTimer -= dt;
    player.vy += GRAVITY * dt;

    let moveX = player.vx * dt, moveY = player.vy * dt;
    const dist = Math.hypot(moveX, moveY);
    const micro = Math.max(1, Math.ceil(dist / MAX_SUBSTEP));
    
    for (let s=0; s<micro; s++) {
      const sx = moveX / micro, sy = moveY / micro;

      if (player.crouching && player.onGround && Math.abs(sx) > 0) {
        const direction = sx > 0 ? 1 : -1;
        const checkX = player.x + (direction > 0 ? player.w : 0) + sx;
        const feetY = player.y + player.h;
        const nextBlockX = Math.floor(checkX / TILE);
        const feetBlockY = Math.floor(feetY / TILE);
        const blockBelow = tileAt(nextBlockX, feetBlockY);
        const blockAtFeet = tileAt(Math.floor((player.x + player.w/2) / TILE), feetBlockY);
        
        if (!blockBelow || !BLOCKS[blockBelow].solid) {
          if (blockAtFeet && BLOCKS[blockAtFeet].solid) {
            moveX = 0; player.vx = 0; break;
          }
        }
      }

      player.x += sx;
      const overlX = tilesOverlapping(player.x, player.y, player.w, player.h);
      for (const t of overlX) {
        if (t.id && BLOCKS[t.id].solid) {
          const box = { x: t.tx * TILE, y: t.ty * TILE, w: TILE, h: TILE };
          if (aabbOverlap(player.x, player.y, player.w, player.h, box.x, box.y, box.w, box.h)) {
            if (sx > 0) player.x = box.x - player.w;
            else if (sx < 0) player.x = box.x + box.w;
            player.vx = 0; break;
          }
        }
      }

      player.y += sy;
      const overlY = tilesOverlapping(player.x, player.y, player.w, player.h);
      player.onGround = false;
      
      for (const t of overlY) {
        if (t.id && BLOCKS[t.id].solid) {
          const box = { x: t.tx * TILE, y: t.ty * TILE, w: TILE, h: TILE };
          if (aabbOverlap(player.x, player.y, player.w, player.h, box.x, box.y, box.w, box.h)) {
            if (sy > 0) { player.y = box.y - player.h; player.vy = 0; player.onGround = true; }
            else if (sy < 0) { player.y = box.y + box.h; player.vy = 0; }
            break;
          }
        }
      }
    }

    if (player.x < 0) { player.x = 0; player.vx = 0; }
    if (player.x + player.w > WORLD_W * TILE) { player.x = WORLD_W * TILE - player.w; player.vx = 0; }
  }

  function checkCollision(x, y, w, h) {
    const tiles = tilesOverlapping(x, y, w, h);
    for (const t of tiles) {
      if (t.id && BLOCKS[t.id].solid) {
        const box = { x: t.tx * TILE, y: t.ty * TILE, w: TILE, h: TILE };
        if (aabbOverlap(x, y, w, h, box.x, box.y, box.w, box.h)) return true;
      }
    }
    return false;
  }

  // ---------- Game logic ----------
  const mining = { bx:-1, by:-1, progress:0, toolPower:40 };

  function gameLogicStep(dt) {
    const cam = getCamera();
    const mouseLogicalX = mouse.x / currentZoom, mouseLogicalY = mouse.y / currentZoom;
    const worldX = cam.x + mouseLogicalX, worldY = cam.y + mouseLogicalY;
    const mbx = Math.floor(worldX / TILE), mby = Math.floor(worldY / TILE);
    const pcx = player.x + player.w/2, pcy = player.y + player.h/2;
    const distTiles = Math.hypot((mbx+0.5)*TILE - pcx, (mby+0.5)*TILE - pcy) / TILE;
    const inReach = distTiles <= REACH_TILES;

    if (mouse.left && inReach && mbx>=0 && mbx < WORLD_W && mby>=0 && mby < WORLD_H && tileAt(mbx,mby) !== 0) {
      const id = tileAt(mbx, mby), hp = BLOCKS[id].hp;
      if (mining.bx !== mbx || mining.by !== mby) {
        mining.bx = mbx; mining.by = mby; mining.progress = 0;
      } else {
        mining.progress += mining.toolPower * dt;
        if (mining.progress >= hp) {
          const drop = BLOCKS[id].drop || id;
          addToInventory(drop, 1);
          map[idx(mbx, mby)] = 0;
          mining.bx = mining.by = -1; mining.progress = 0;
        }
      }
    } else {
      if (!mouse.left) { mining.progress = 0; mining.bx = mining.by = -1; }
    }

    if (mouse.right && !mouse.lastRight) {
      if (inReach && mbx>=0 && mbx < WORLD_W && mby>=0 && mby < WORLD_H && tileAt(mbx, mby) === 0) {
        const tilePx = mbx * TILE, tilePy = mby * TILE;
        if (!aabbOverlap(player.x, player.y, player.w, player.h, tilePx, tilePy, TILE, TILE)) {
          const sel = player.selected;
          if (totalCount(sel) > 0) { map[idx(mbx, mby)] = sel; removeFromInventory(sel, 1); }
        }
      }
    }
    mouse.lastRight = mouse.right;
  }

  // ---------- Day/night system ----------
  function getTimeLight() {
    const elapsed = (Date.now() - worldStartTime) % CYCLE_MS;
    const t = elapsed / CYCLE_MS, angle = t * Math.PI * 2;
    const raw = (Math.sin(angle - Math.PI/2) + 1) / 2;
    return { t, angle, light: Math.max(0.02, raw) };
  }

  function lerpColor(a, b, f) {
    const pa = parseInt(a.slice(1), 16), pb = parseInt(b.slice(1), 16);
    const ar = pa >> 16, ag = (pa >> 8) & 0xff, ab = pa & 0xff;
    const br = pb >> 16, bg = (pb >> 8) & 0xff, bb = pb & 0xff;
    const rr = Math.round(ar + (br - ar) * f);
    const rg = Math.round(ag + (bg - ag) * f);
    const rb = Math.round(ab + (bb - ab) * f);
    return "#" + ((1<<24) + (rr<<16) + (rg<<8) + rb).toString(16).slice(1);
  }

  function getClockLabel() {
    const now = Date.now();
    const cyc = ((now - worldStartTime) % CYCLE_MS) / CYCLE_MS;
    const hour = Math.floor(cyc * 24), min = Math.floor((cyc * 24 - hour) * 60);
    return `${String(hour).padStart(2,'0')}:${String(min).padStart(2,'0')}`;
  }

  // ---------- Camera ----------
  function getLogicalViewSize() {
    const cssW = Math.max(800, window.innerWidth), cssH = Math.max(600, window.innerHeight);
    return { viewW: cssW / currentZoom, viewH: cssH / currentZoom, cssW, cssH };
  }

  function getCamera() {
    const { viewW, viewH } = getLogicalViewSize();
    const cx = Math.round(player.x + player.w/2 - viewW/2);
    const cy = Math.round(player.y + player.h/2 - viewH/2);
    const maxX = WORLD_W * TILE - viewW, maxY = WORLD_H * TILE - viewH;
    return { x: Math.max(0, Math.min(maxX, cx)), y: Math.max(0, Math.min(maxY, cy)), w: viewW, h: viewH };
  }

  // ---------- Rendering ----------
  function drawTile(ctx, id, bx, by, lightFactor=1) {
    const tex = texCache.get(id);
    if (tex) {
      ctx.drawImage(tex, Math.round(bx), Math.round(by), TILE, TILE);
      if (lightFactor !== 1) {
        ctx.fillStyle = `rgba(0,0,0,${1-lightFactor})`;
        ctx.fillRect(bx, by, TILE, TILE);
      }
    } else {
      ctx.fillStyle = (BLOCKS[id] && BLOCKS[id].color) || "#fff";
      ctx.fillRect(bx, by, TILE, TILE);
    }
  }

  function renderBackground() {
    const cssW = Math.max(800, window.innerWidth), cssH = Math.max(600, window.innerHeight);
    bgCanvas.width = Math.floor(cssW * devicePixelRatio_);
    bgCanvas.height = Math.floor(cssH * devicePixelRatio_);
    bgCanvas.style.width = cssW + "px"; bgCanvas.style.height = cssH + "px";
    bgCtx.setTransform(1, 0, 0, 1, 0, 0);
    bgCtx.imageSmoothingEnabled = false;

    const { angle, light } = getTimeLight();
    const dayTop = "#71BCE1", dayBot = "#DDEFF7";
    const duskTop = "#FFB96C", duskBot = "#F6CB69";
    const nightTop = "#081023", nightBot = "#02020a";
    
    let topColor, botColor;
    if (light >= 0.6) {
      const f = Math.min(1, (light - 0.6) / 0.4);
      topColor = lerpColor(duskTop, dayTop, f);
      botColor = lerpColor(duskBot, dayBot, f);
    } else if (light >= 0.2) {
      const f = (light - 0.2) / 0.4;
      topColor = lerpColor(nightTop, duskTop, f);
      botColor = lerpColor(nightBot, duskBot, f);
    } else { topColor = nightTop; botColor = nightBot; }
    
    const grad = bgCtx.createLinearGradient(0, 0, bgCanvas.width, bgCanvas.height);
    grad.addColorStop(0, topColor); grad.addColorStop(1, botColor);
    bgCtx.fillStyle = grad;
    bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);

    const sunX = bgCanvas.width/2 + Math.cos(angle) * bgCanvas.width * 0.36;
    const sunY = bgCanvas.height/2 - Math.sin(angle) * bgCanvas.height * 0.38;
    const sunAlpha = Math.max(0, (light - 0.18) / 0.82);
    const sunAboveHorizon = Math.sin(angle) > 0;
    
    if (sunAlpha > 0.01 && sunAboveHorizon) {
      const s = 36 * devicePixelRatio_;
      const g = bgCtx.createRadialGradient(sunX, sunY, 0, sunX, sunY, s * 3.2);
      g.addColorStop(0, `rgba(255,230,140,${0.95*sunAlpha})`);
      g.addColorStop(0.3, `rgba(255,200,80,${0.35*sunAlpha})`);
      g.addColorStop(1, `rgba(255,200,80,0)`);
      bgCtx.fillStyle = g;
      bgCtx.fillRect(sunX - s*4, sunY - s*4, s*8, s*8);
      bgCtx.beginPath();
      bgCtx.fillStyle = `rgba(255,235,140,${0.98*sunAlpha})`;
      bgCtx.arc(sunX, sunY, s, 0, Math.PI * 2);
      bgCtx.fill();
    }

    const moonAlpha = Math.max(0, (0.72 - light) / 0.72);
    const moonVisible = !sunAboveHorizon;
    
    if (moonAlpha > 0.01 && moonVisible) {
      const mX = bgCanvas.width * 0.28, mY = bgCanvas.height * 0.18;
      bgCtx.beginPath();
      bgCtx.fillStyle = `rgba(220,230,255,${0.95*moonAlpha})`;
      bgCtx.arc(mX, mY, 22 * devicePixelRatio_, 0, Math.PI * 2);
      bgCtx.fill();
      bgCtx.globalCompositeOperation = 'destination-out';
      bgCtx.beginPath();
      bgCtx.arc(mX + 6*devicePixelRatio_, mY - 2*devicePixelRatio_, 18*devicePixelRatio_, 0, Math.PI * 2);
      bgCtx.fill();
      bgCtx.globalCompositeOperation = 'source-over';
    }

    const starAlphaBase = Math.max(0, (0.62 - light) / 0.62);
    if (starAlphaBase > 0.02) {
      for (let i=0; i<stars.length; i++) {
        const s = stars[i];
        const tw = 0.6 + 0.8 * Math.abs(Math.sin((performance.now() / (900 + s.twinkle*700)) + (s.twinkle*10)));
        const baseA = Math.min(1, starAlphaBase * (0.8 + 0.8 * (1 - s.depth)));
        const a = Math.min(1, baseA * tw * s.brightness);
        const ci = parseInt(s.color.slice(1), 16);
        const cr = (ci >> 16) & 0xff, cg = (ci >> 8) & 0xff, cb = ci & 0xff;
        bgCtx.fillStyle = `rgba(${cr},${cg},${cb},${a})`;
        const size = Math.max(1, Math.round(s.size * (1 + (1 - s.depth)))) * devicePixelRatio_;
        bgCtx.fillRect(s.x * devicePixelRatio_, s.y * devicePixelRatio_, Math.max(1, size), Math.max(1, size));
      }
    }

    if (gameState === "title" || gameState === "settings") {
      bgCtx.fillStyle = "rgba(0, 0, 0, 0.6)";
      bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
    }
  }

  let frameCount = 0, fps = 0, fpsLast = performance.now();

  function renderWorld() {
    currentZoom += (targetZoom - currentZoom) * 0.12;
    const cssW = Math.max(800, window.innerWidth), cssH = Math.max(600, window.innerHeight);
    const dpr = devicePixelRatio_;
    worldCanvas.width = Math.floor(cssW * dpr);
    worldCanvas.height = Math.floor(cssH * dpr);
    worldCanvas.style.width = cssW + "px"; worldCanvas.style.height = cssH + "px";
    wctx.setTransform(dpr * currentZoom, 0, 0, dpr * currentZoom, 0, 0);
    wctx.imageSmoothingEnabled = false;

    const { viewW, viewH } = getLogicalViewSize();
    wctx.clearRect(0, 0, viewW, viewH);

    const cam = getCamera();
    const startX = Math.floor(cam.x / TILE) - 1, endX = Math.ceil((cam.x + cam.w) / TILE) + 1;
    const startY = Math.floor(cam.y / TILE) - 1, endY = Math.ceil((cam.y + cam.h) / TILE) + 1;
    const light = getTimeLight().light, ambientDark = 1 - light;
    
    for (let ty = startY; ty <= endY; ty++) {
      if (ty < 0 || ty >= WORLD_H) continue;
      for (let tx = startX; tx <= endX; tx++) {
        if (tx < 0 || tx >= WORLD_W) continue;
        const id = tileAt(tx, ty);
        if (!id) continue;
        const bx = tx * TILE - cam.x, by = ty * TILE - cam.y;
        const def = BLOCKS[id], baseCol = def && def.color ? def.color : "#fff";
        let ci = 0xffffff;
        try { ci = parseInt(baseCol.slice(1), 16); } catch(e) {}
        const br = (ci >> 16) & 0xff, bg = (ci >> 8) & 0xff, bb = ci & 0xff;
        const darkFactor = 1 - ambientDark * 0.5;
        const rr = Math.round(br * darkFactor), rg = Math.round(bg * darkFactor), rb = Math.round(bb * darkFactor);
        wctx.fillStyle = `rgb(${rr},${rg},${rb})`;
        wctx.fillRect(bx, by, TILE, TILE);
        drawTile(wctx, id, bx, by, darkFactor);
      }
    }

    const px = player.x - cam.x, py = player.y - cam.y;
    drawPlayerSprite(wctx, px, py, player.w, player.h);

    const mouseLogicalX = mouse.x / currentZoom, mouseLogicalY = mouse.y / currentZoom;
    const worldX = cam.x + mouseLogicalX, worldY = cam.y + mouseLogicalY;
    const mbx = Math.floor(worldX / TILE), mby = Math.floor(worldY / TILE);
    const pcx = player.x + player.w/2, pcy = player.y + player.h/2;
    const distT = Math.hypot((mbx+0.5)*TILE - pcx, (mby+0.5)*TILE - pcy) / TILE;
    const reach = distT <= REACH_TILES && mby >= 0 && mby < WORLD_H;
    
    if (mbx >= 0 && mby >= 0 && mby < WORLD_H) {
      const tx = mbx * TILE - cam.x, ty = mby * TILE - cam.y;
      wctx.lineWidth = 2;
      wctx.strokeStyle = reach ? "rgba(255,255,255,0.95)" : "rgba(255,255,255,0.25)";
      wctx.strokeRect(tx + 1, ty + 1, TILE - 2, TILE - 2);
    }

    if (mining.bx >= 0 && mining.by >= 0) {
      const tx = mining.bx * TILE - cam.x, ty = mining.by * TILE - cam.y;
      const bid = tileAt(mining.bx, mining.by);
      const hp = (BLOCKS[bid] && BLOCKS[bid].hp) || 1;
      const frac = Math.min(1, mining.progress / Math.max(1, hp));
      wctx.fillStyle = "rgba(0,0,0,0.35)";
      wctx.fillRect(tx, ty + TILE - 4, TILE, 4);
      wctx.fillStyle = "rgba(255,255,255,0.9)";
      wctx.fillRect(tx, ty + TILE - 4, TILE * frac, 4);
    }
  }

  function renderHUD() {
    renderBackground();
    const cssW = Math.max(800, window.innerWidth), cssH = Math.max(600, window.innerHeight);
    overlay.width = Math.floor(cssW * devicePixelRatio_);
    overlay.height = Math.floor(cssH * devicePixelRatio_);
    overlay.style.width = cssW + "px"; overlay.style.height = cssH + "px";
    octx.setTransform(1, 0, 0, 1, 0, 0);
    octx.imageSmoothingEnabled = false;

    const now = performance.now();
    frameCount++;
    if (now - fpsLast >= 1000) { fps = frameCount; frameCount = 0; fpsLast = now; }
    
    octx.font = `bold ${24*devicePixelRatio_}px Arial, Helvetica, sans-serif`;
    octx.fillStyle = "rgba(0,0,0,0.7)";
    octx.textAlign = "center";
    const timeText = getClockLabel();
    const timeX = (cssW / 2) * devicePixelRatio_, timeY = 40 * devicePixelRatio_;
    const timeMetrics = octx.measureText(timeText);
    const timePadding = 12 * devicePixelRatio_;
    roundRect(octx, timeX - (timeMetrics.width / 2) - timePadding, timeY - 20 * devicePixelRatio_, 
      timeMetrics.width + timePadding * 2, 32 * devicePixelRatio_, 8 * devicePixelRatio_, true, false);
    octx.fillStyle = "#fff";
    octx.fillText(timeText, timeX, timeY);
    octx.textAlign = "left";

    if (gameState !== "playing") return;

    octx.fillStyle = "rgba(0,0,0,0.55)";
    octx.fillRect(10*devicePixelRatio_, cssH*devicePixelRatio_ - 86*devicePixelRatio_, 360*devicePixelRatio_, 86*devicePixelRatio_);
    octx.fillStyle = "#fff";
    octx.font = `${12*devicePixelRatio_}px monospace`;
    octx.fillText(`Pos: ${(player.x/TILE).toFixed(2)}, ${(player.y/TILE).toFixed(2)}`, 18*devicePixelRatio_, cssH*devicePixelRatio_ - 64*devicePixelRatio_);
    octx.fillText(`Vel: ${(player.vx).toFixed(0)} , ${(player.vy).toFixed(0)}`, 18*devicePixelRatio_, cssH*devicePixelRatio_ - 44*devicePixelRatio_);
    octx.fillStyle = "rgba(0,0,0,0.65)";
    roundRect(octx, 18*devicePixelRatio_, cssH*devicePixelRatio_ - 110*devicePixelRatio_, 64*devicePixelRatio_, 18*devicePixelRatio_, 6*devicePixelRatio_, true, false);
    octx.fillStyle = "#fff";
    octx.fillText(`FPS: ${fps}`, 24*devicePixelRatio_, cssH*devicePixelRatio_ - 96*devicePixelRatio_);

    const visibleIds = Object.keys(inventory).map(Number).filter(id => id !== 0 && inventory[id] && inventory[id].length > 0).sort((a,b) => a-b);
    const slotCount = Math.max(visibleIds.length, 1);
    const slotSize = TILE, padding = 8, spacing = 6;
    const barW = Math.max(220, padding*2 + slotCount*slotSize + (slotCount-1)*spacing);
    const barH = slotSize + padding*2;
    const bx0 = Math.round((cssW - barW)/2), by0 = cssH - barH - 18;
    octx.fillStyle = "rgba(0,0,0,0.5)";
    roundRect(octx, bx0*devicePixelRatio_, by0*devicePixelRatio_, barW*devicePixelRatio_, barH*devicePixelRatio_, 8*devicePixelRatio_, true, false);

    for (let i=0; i<visibleIds.length; i++) {
      const id = visibleIds[i];
      const sx = bx0 + padding + i*(slotSize + spacing), sy = by0 + padding;
      octx.fillStyle = BLOCKS[id] && BLOCKS[id].color || "#333";
      octx.fillRect(sx*devicePixelRatio_, sy*devicePixelRatio_, slotSize*devicePixelRatio_, slotSize*devicePixelRatio_);
      const tex = texCache.get(id);
      if (tex) octx.drawImage(tex, sx*devicePixelRatio_, sy*devicePixelRatio_, slotSize*devicePixelRatio_, slotSize*devicePixelRatio_);
      octx.lineWidth = (player.selected === id) ? 3*devicePixelRatio_ : 1*devicePixelRatio_;
      octx.strokeStyle = (player.selected === id) ? "#fff" : "rgba(0,0,0,0.2)";
      octx.strokeRect((sx - ((player.selected === id)?3:0))*devicePixelRatio_, (sy - ((player.selected === id)?3:0))*devicePixelRatio_, (slotSize + ((player.selected === id)?6:0))*devicePixelRatio_, (slotSize + ((player.selected === id)?6:0))*devicePixelRatio_);
      const mxc = mouse.x, myc = mouse.y;
      const inside = (mxc >= sx && mxc <= sx + slotSize && myc >= sy && myc <= sy + slotSize);
      octx.fillStyle = "#fff";
      octx.font = `${12*devicePixelRatio_}px monospace`;
      const total = totalCount(id);
      if (inside) {
        const name = BLOCKS[id].name;
        const textW = octx.measureText(name).width;
        const tx = sx + slotSize/2 - (textW / devicePixelRatio_) / 2, ty = sy - 14;
        octx.fillStyle = "rgba(0,0,0,0.75)";
        roundRect(octx, (tx - 6)*devicePixelRatio_, (ty - 12)*devicePixelRatio_, (textW + 12)*devicePixelRatio_, 16*devicePixelRatio_, 6*devicePixelRatio_, true, false);
        octx.fillStyle = "#fff";
        octx.fillText(name, tx*devicePixelRatio_, ty*devicePixelRatio_);
      } else {
        octx.fillText(`x${total}`, (sx + slotSize - 22)*devicePixelRatio_, (sy + slotSize - 6)*devicePixelRatio_);
      }
    }
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    if (w < 2*r) r = w/2;
    if (h < 2*r) r = h/2;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  let running = true, accumulator = 0, last = performance.now();

  function frame(now) {
    if (!running) return;
    requestAnimationFrame(frame);
    let delta = (now - last) / 1000;
    if (delta > 0.25) delta = 0.25;
    last = now;
    if (gameState === "playing") {
      accumulator += delta;
      while (accumulator >= DT) {
        physicsStep(DT);
        gameLogicStep(DT);
        accumulator -= DT;
      }
      renderWorld();
    } else {
      wctx.clearRect(0, 0, worldCanvas.width, worldCanvas.height);
    }
    renderHUD();
  }

  // ---------- Init ----------
  gameState = "title";
  generateTerrain();
  buildAllTextures();
  generateStars(420);
  spawnPlayer();
  requestAnimationFrame(frame);

  function resizeAll() {
    const cssW = Math.max(800, window.innerWidth), cssH = Math.max(600, window.innerHeight);
    worldCanvas.style.width = cssW + "px"; worldCanvas.style.height = cssH + "px";
    bgCanvas.style.width = cssW + "px"; bgCanvas.style.height = cssH + "px";
    overlay.style.width = cssW + "px"; overlay.style.height = cssH + "px";
    buildAllTextures();
    generateStars(Math.max(200, Math.floor(cssW * cssH / 30000)));
  }
  window.addEventListener("resize", resizeAll);

  function destroy() {
    running = false;
    try { window.removeEventListener("resize", resizeAll); } catch(e) {}
    try { sliderWrap.remove(); } catch(e) {}
    try { help.remove(); } catch(e) {}
    try { titleScreen.remove(); } catch(e) {}
    try { settingsScreen.remove(); } catch(e) {}
    try { bgCanvas.remove(); worldCanvas.remove(); overlay.remove(); root.remove(); } catch(e) {}
    try { delete window.miniCraftFixed; } catch(e) {}
    console.log("Mini-craft destroyed.");
  }

  window.miniCraftFixed = {
    destroy, map, WORLD_W, WORLD_H, TILE,
    getTile: (x,y) => (x>=0 && x<WORLD_W && y>=0 && y<WORLD_H) ? map[idx(x,y)] : 0,
    setTile: (x,y,id) => { if (x>=0 && x<WORLD_W && y>=0 && y<WORLD_H) map[idx(x,y)] = id; },
    addToInventory, removeFromInventory, totalCount, BLOCKS
  };

  console.log("Mini-craft with smooth terrain and hills running!");
  console.log("Arms are now positioned OUTSIDE the player body!");
  console.log("Press ESC during gameplay to return to menu.");
  console.log("Call window.miniCraftFixed.destroy() to remove the game.");
})();

